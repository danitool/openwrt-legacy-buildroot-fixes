diff --git a/package/mac80211/patches/622-rt2x00-backport-fix-beacon-bit-balance.patch b/package/mac80211/patches/622-rt2x00-backport-fix-beacon-bit-balance.patch
new file mode 100644
index 0000000..04885dc
--- /dev/null
+++ b/package/mac80211/patches/622-rt2x00-backport-fix-beacon-bit-balance.patch
@@ -0,0 +1,55 @@
+--- a/drivers/net/wireless/rt2x00/rt2x00dev.c
++++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
+@@ -142,9 +142,10 @@
+ 		return;
+ 
+ 	if (test_and_clear_bit(DELAYED_UPDATE_BEACON, &intf->delayed_flags)) {
+ 		mutex_lock(&intf->beacon_skb_mutex);
+-		rt2x00queue_update_beacon(rt2x00dev, vif);
++		if (intf->enable_beacon)
++			rt2x00queue_update_beacon(rt2x00dev, vif);
+ 		mutex_unlock(&intf->beacon_skb_mutex);
+ 	}
+ }
+ 
+@@ -205,8 +206,9 @@
+ static void rt2x00lib_beaconupdate_iter(void *data, u8 *mac,
+ 					struct ieee80211_vif *vif)
+ {
+ 	struct rt2x00_dev *rt2x00dev = data;
++	struct rt2x00_intf *intf = vif_to_intf(vif);
+ 
+ 	if (vif->type != NL80211_IFTYPE_AP &&
+ 	    vif->type != NL80211_IFTYPE_ADHOC &&
+ 	    vif->type != NL80211_IFTYPE_MESH_POINT &&
+@@ -218,9 +220,10 @@
+ 	 * as they only update the beacon periodically here. This should
+ 	 * never be called for USB devices.
+ 	 */
+ 	WARN_ON(rt2x00_is_usb(rt2x00dev));
+-	rt2x00queue_update_beacon(rt2x00dev, vif);
++	if (intf->enable_beacon)
++		rt2x00queue_update_beacon(rt2x00dev, vif);
+ }
+ 
+ void rt2x00lib_beacondone(struct rt2x00_dev *rt2x00dev)
+ {
+--- a/drivers/net/wireless/rt2x00/rt2x00mac.c
++++ b/drivers/net/wireless/rt2x00/rt2x00mac.c
+@@ -646,14 +646,10 @@
+ 			rt2x00queue_clear_beacon(rt2x00dev, vif);
+ 		} else if (bss_conf->enable_beacon && !intf->enable_beacon) {
+ 			rt2x00dev->intf_beaconing++;
+ 			intf->enable_beacon = true;
+-			/*
+-			 * Upload beacon to the H/W. This is only required on
+-			 * USB devices. PCI devices fetch beacons periodically.
+-			 */
+-			if (rt2x00_is_usb(rt2x00dev))
+-				rt2x00queue_update_beacon(rt2x00dev, vif);
++
++			rt2x00queue_update_beacon(rt2x00dev, vif);
+ 
+ 			if (rt2x00dev->intf_beaconing == 1) {
+ 				/*
+ 				 * First beaconing interface enabled
diff --git a/package/mac80211/patches/623-rt2x00-backport-fix-Error_Dropping_frame_due_to_full_tx_queue.patch b/package/mac80211/patches/623-rt2x00-backport-fix-Error_Dropping_frame_due_to_full_tx_queue.patch
new file mode 100644
index 0000000..616b9ba
--- /dev/null
+++ b/package/mac80211/patches/623-rt2x00-backport-fix-Error_Dropping_frame_due_to_full_tx_queue.patch
@@ -0,0 +1,70 @@
+--- a/drivers/net/wireless/rt2x00/rt2x00mac.c
++++ b/drivers/net/wireless/rt2x00/rt2x00mac.c
+@@ -141,34 +141,30 @@
+ 	 */
+ 	if (!rt2x00dev->ops->hw->set_rts_threshold &&
+ 	    (tx_info->control.rates[0].flags & (IEEE80211_TX_RC_USE_RTS_CTS |
+ 						IEEE80211_TX_RC_USE_CTS_PROTECT))) {
+-		if (rt2x00queue_available(queue) <= 1)
+-			goto exit_fail;
++		if (rt2x00queue_available(queue) <= 1) {
++			/*
++			 * Recheck for full queue under lock to avoid race
++			 * conditions with rt2x00lib_txdone().
++			 */
++			spin_lock(&queue->tx_lock);
++			if (rt2x00queue_threshold(queue))
++				rt2x00queue_pause_queue(queue);
++			spin_unlock(&queue->tx_lock);
++
++			goto exit_free_skb;
++		}
+ 
+ 		if (rt2x00mac_tx_rts_cts(rt2x00dev, queue, skb))
+-			goto exit_fail;
++			goto exit_free_skb;
+ 	}
+ 
+ 	if (unlikely(rt2x00queue_write_tx_frame(queue, skb, control->sta, false)))
+-		goto exit_fail;
+-
+-	/*
+-	 * Pausing queue has to be serialized with rt2x00lib_txdone(). Note
+-	 * we should not use spin_lock_bh variant as bottom halve was already
+-	 * disabled before ieee80211_xmit() call.
+-	 */
+-	spin_lock(&queue->tx_lock);
+-	if (rt2x00queue_threshold(queue))
+-		rt2x00queue_pause_queue(queue);
+-	spin_unlock(&queue->tx_lock);
++		goto exit_free_skb;
+ 
+ 	return;
+ 
+- exit_fail:
+-	spin_lock(&queue->tx_lock);
+-	rt2x00queue_pause_queue(queue);
+-	spin_unlock(&queue->tx_lock);
+  exit_free_skb:
+ 	ieee80211_free_txskb(hw, skb);
+ }
+ EXPORT_SYMBOL_GPL(rt2x00mac_tx);
+--- a/drivers/net/wireless/rt2x00/rt2x00queue.c
++++ b/drivers/net/wireless/rt2x00/rt2x00queue.c
+@@ -719,8 +719,16 @@
+ 	rt2x00queue_write_tx_descriptor(entry, &txdesc);
+ 	rt2x00queue_kick_tx_queue(queue, &txdesc);
+ 
+ out:
++	/*
++	 * Pausing queue has to be serialized with rt2x00lib_txdone(), so we
++	 * do this under queue->tx_lock. Bottom halve was already disabled
++	 * before ieee80211_xmit() call.
++	 */
++	if (rt2x00queue_threshold(queue))
++		rt2x00queue_pause_queue(queue);
++
+ 	spin_unlock(&queue->tx_lock);
+ 	return ret;
+ }
+ 
